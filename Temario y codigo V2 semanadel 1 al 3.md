# **Planeaci√≥n Did√°ctica: Programaci√≥n L√≥gica e Inteligencia Artificial con Python**
**Nivel:** Preparatoria - B√°sico  
**Plataforma:** Google Colab  
**Duraci√≥n:** 40 horas (8 semanas de 5 horas cada una)  
**Lenguaje:** Python

---

## **FUNDAMENTACI√ìN**
Esta planeaci√≥n introduce a los estudiantes en la programaci√≥n l√≥gica y conceptos b√°sicos de IA mediante Python en Colab, partiendo de un diagn√≥stico inicial que eval√∫a conocimientos previos y viabilidad de implementaci√≥n. Se utilizar√°n proyectos atractivos y contempor√°neos para mantener el inter√©s, desarrollando competencias de pensamiento algor√≠tmico y l√≥gico.

---

## **DIAGN√ìSTICO INICIAL (Primera hora)**
**Objetivo:** Evaluar conocimientos previos y ajustar ritmo de ense√±anza.

### **Actividades del docente:**
- Aplicar cuestionario digital sobre l√≥gica b√°sica y experiencia con Python
- Demostrar breve ejemplo en Colab (saludo interactivo)
- Explicar estructura del curso y objetivos

### **Actividades del alumno:**
- Responder diagn√≥stico en formulario Google
- Crear su primer notebook en Colab y ejecutar celda de prueba
- Compartir expectativas del curso en documento colaborativo

---

## **ESTRUCTURA GENERAL POR SEMANA**

### **SEMANA 1: Fundamentos de Python y L√≥gica Computacional (5 hrs)**
**Objetivo:** Establecer bases de Python y pensamiento l√≥gico.

#### **Apertura (1 hr)**
- **Docente:** Presenta concepto de "l√≥gica en la vida diaria" con ejemplos (decisiones, reglas)
- **Alumnos:** Identifican reglas l√≥gicas en redes sociales (ej. "Si subo foto, entonces mis amigos la ven")

#### **Desarrollo (3 hrs)**
- **Pr√°ctica demostrativa:** Operadores booleanos con memes
- **Pr√°ctica guiada:** Calculadora de IMC con condiciones
- **Pr√°ctica supervisada:** Sistema de recomendaci√≥n simple de pel√≠culas

#### **Cierre (1 hr)**
- **Alumnos:** Comparten sus programas funcionando
- **Docente:** Retroalimentaci√≥n y conexi√≥n con IA

---

### **SEMANA 2: Estructuras de Datos para L√≥gica (5 hrs)**
**Objetivo:** Manipular datos para tomar decisiones.

#### **Proyecto atractivo:** "Recomendador de Playlists"
- **Apertura:** An√°lisis de c√≥mo Spotify sugiere m√∫sica
- **Desarrollo:** 
  - Listas y diccionarios con g√©neros musicales
  - Sistema de preferencias por usuario
- **Cierre:** Demo entre compa√±eros

---

### **SEMANA 3: Funciones y M√≥dulos L√≥gicos (5 hrs)**
**Objetivo:** Modularizar programas con funciones reutilizables.

#### **Proyecto atractivo:** "Asistente de Tareas Inteligente"
- **Apertura:** Discusi√≥n sobre asistentes virtuales
- **Desarrollo:**
  - Funciones para a√±adir/eliminar tareas
  - "Inteligencia" b√°sica: sugerir tareas por hora del d√≠a
- **Cierre:** Integraci√≥n con Google Calendar API b√°sica

---

### **SEMANA 4: Introducci√≥n a la Programaci√≥n L√≥gica (5 hrs)**
**Objetivo:** Implementar sistemas basados en reglas.

#### **Proyecto atractivo:** "Chatbot de Consejos de Estudio"
- **Apertura:** An√°lisis de chatbots educativos
- **Desarrollo:**
  - Sistema de reglas "if-elif-else" anidado
  - Base de conocimiento simple en diccionarios
- **Cierre:** Competencia: ¬øQui√©n tiene el chatbot m√°s √∫til?

---

### **SEMANA 5: Algoritmos de B√∫squeda (5 hrs)**
**Objetivo:** Comprender c√≥mo las m√°quinas "piensan" soluciones.

#### **Proyecto atractivo:** "Resuelve-laberintos Digital"
- **Apertura:** Juego manual de laberinto en papel
- **Desarrollo:**
  - Implementaci√≥n de b√∫squeda en amplitud
  - Visualizaci√≥n con matplotlib
- **Cierre:** Comparaci√≥n humana vs algoritmo

---

### **SEMANA 6: Simulaciones de Comportamiento Inteligente (5 hrs)**
**Objetivo:** Modelar decisiones humanas en algoritmos.

#### **Proyecto atractivo:** "Simulador de Tr√°fico Inteligente"
- **Apertura:** Video de tr√°fico ca√≥tico vs organizado
- **Desarrollo:**
  - Sem√°foros que responden a "tr√°fico"
  - Autos que toman decisiones b√°sicas
- **Cierre:** An√°lisis √©tico: ¬øoptimizar por velocidad o seguridad?

---

### **SEMANA 7: Procesamiento de Lenguaje Natural B√°sico (5 hrs)**
**Objetivo:** Introducir IA que "comprende" lenguaje.

#### **Proyecto atractivo:** "Analizador de Sentimientos de Tweets"
- **Apertura:** C√≥mo las empresas analizan opiniones
- **Desarrollo:**
  - Listas de palabras positivas/negativas
  - Contador de sentimientos por texto
- **Cierre:** Discusi√≥n sobre privacidad y √©tica en IA

---

### **SEMANA 8: Proyecto Final Integrador (5 hrs)**
**Objetivo:** Aplicar todos los conceptos en proyecto personal.

#### **Apertura (1 hr)**
- **Docente:** Presenta r√∫brica y ejemplos de proyectos
- **Alumnos:** Brainstorming de ideas en tablero colaborativo

#### **Desarrollo (3 hrs)**
- **Pr√°ctica aut√≥noma:** Desarrollo de proyecto individual
- **Docente:** Asesor√≠a personalizada por alumno

#### **Cierre (1 hr)**
- **Feria de proyectos:** Cada alumno presenta su trabajo
- **Evaluaci√≥n entre pares:** Feedback estructurado
- **Reflexi√≥n final:** ¬øC√≥mo simula inteligencia humana su proyecto?

---

## **EVALUACI√ìN CONTINUA**

| Componente | Ponderaci√≥n | Evidencia |
|------------|-------------|-----------|
| Diagn√≥stico inicial | 5% | Cuestionario y ejercicio inicial |
| Laboratorios guiados | 30% | 7 notebooks completados |
- **Participaci√≥n activa** | 15% | Intervenciones en discusiones |
- **Proyecto final** | 40% | C√≥digo, presentaci√≥n y reflexi√≥n |
- **Autoevaluaci√≥n** | 10% | R√∫brica de metacognici√≥n |

---

## **RECURSOS Y HERRAMIENTAS**

1. **Plataforma principal:** Google Colab
2. **Material complementario:** 
   - Videos cortos de conceptos clave
   - Jupyter notebooks de ejemplo
   - Banco de problemas graduados
3. **Ejemplos ilustrativos:**
   - Comparador de precios de videojuegos
   - Recomendador de outfits por clima
   - Asistente para h√°bitos de estudio
   - Clasificador simple de memes

---

## **ADAPTACIONES ESPEC√çFICAS**

### **Para alumnos con menos experiencia:**
- Sesiones de recuperaci√≥n con ejercicios adicionales
- Parejas de programaci√≥n
- Plantillas de c√≥digo parcialmente completadas

### **Para alumnos avanzados:**
- Desaf√≠os opcionales con mayor complejidad
- Opci√≥n de usar librer√≠as adicionales
- Rol de "asistente t√©cnico" para ayudar a compa√±eros

---

## **CONSIDERACIONES √âTICAS Y SOCIALES**
Cada semana incluye 15 minutos para discutir:
- Impacto social de la tecnolog√≠a creada
- Sesgos en algoritmos
- Uso responsable de datos
- Futuro del trabajo con IA

---

## **RESULTADO ESPERADO**
Al finalizar las 40 horas, los estudiantes:
1. Programar√°n sistemas basados en reglas l√≥gicas en Python
2. Analizar√°n algoritmos que simulan procesos de decisi√≥n humana
3. Evaluar√°n la viabilidad t√©cnica de soluciones computacionales
4. Desarrollar√°n un proyecto completo con aplicaci√≥n pr√°ctica
5. Reflexionar√°n cr√≠ticamente sobre la implementaci√≥n de IA

**Nota:** Esta planeaci√≥n es flexible y se ajustar√° seg√∫n resultados del diagn√≥stico inicial y ritmo del grupo. Se enfatiza el aprendizaje pr√°ctico con proyectos significativos para adolescentes contempor√°neos.




# **Material para el Docente: 3 Ejemplos de C√≥digo por Semana**

## **SEMANA 1: Fundamentos de Python y L√≥gica Computacional**

### **Ejemplo 1: Calculadora de IMC con condiciones (Pr√°ctica guiada)**
```python
# C√ÅLCULO DE IMC CON RECOMENDACI√ìN INTELIGENTE
print("=== CALCULADORA DE IMC INTELIGENTE ===")

# Entrada de datos
nombre = input("¬øC√≥mo te llamas? ")
edad = int(input("¬øCu√°ntos a√±os tienes? "))
peso = float(input("Tu peso en kg: "))
estatura = float(input("Tu estatura en metros: "))

# C√°lculo del IMC
imc = peso / (estatura ** 2)

# L√≥gica de clasificaci√≥n
print(f"\nHola {nombre}, seg√∫n tu edad ({edad} a√±os):")

if imc < 18.5:
    categoria = "Bajo peso"
    recomendacion = "Consulta a un nutricionista para ganar peso saludablemente"
elif 18.5 <= imc < 25:
    categoria = "Peso normal"
    recomendacion = "¬°Excelente! Mant√©n tus h√°bitos saludables"
elif 25 <= imc < 30:
    categoria = "Sobrepeso"
    recomendacion = "Aumenta tu actividad f√≠sica y revisa tu dieta"
else:
    categoria = "Obesidad"
    recomendacion = "Consulta con un profesional de salud para un plan personalizado"

# Resultados con formato
print(f"Tu IMC es: {imc:.2f}")
print(f"Categor√≠a: {categoria}")
print(f"Recomendaci√≥n: {recomendacion}")

# An√°lisis adicional seg√∫n edad
if edad < 18:
    print("üí° Como eres menor de edad, estas categor√≠as deben interpretarse con ayuda de un pediatra")
else:
    print("üí° Para adultos, estas categor√≠as son referencia general")
```

### **Ejemplo 2: Sistema de recomendaci√≥n simple de pel√≠culas**
```python
# SISTEMA DE RECOMENDACI√ìN DE PEL√çCULAS POR G√âNERO
print("üé¨ RECOMENDADOR DE PEL√çCULAS INTELIGENTE üé¨")

# Base de conocimiento (simulando "inteligencia")
peliculas = {
    "acci√≥n": ["Avengers: Endgame", "John Wick", "Mad Max: Fury Road"],
    "comedia": ["Superbad", "La propuesta", "¬øQu√© pas√≥ ayer?"],
    "drama": ["El padrino", "Forrest Gump", "El renacido"],
    "terror": ["It", "El conjuro", "Hereditary"],
    "ciencia ficci√≥n": ["Interstellar", "Matrix", "Blade Runner 2049"]
}

# Preferencias del usuario (simulando aprendizaje)
print("\nG√©neros disponibles: acci√≥n, comedia, drama, terror, ciencia ficci√≥n")
genero = input("¬øQu√© g√©nero te interesa hoy? ").lower()

# L√≥gica de recomendaci√≥n con manejo de errores
if genero in peliculas:
    print(f"\nüí° Basado en tu preferencia por '{genero}', te recomiendo:")
    
    # Selecci√≥n "inteligente" (simulando algoritmo)
    import random
    recomendada = random.choice(peliculas[genero])
    
    print(f"üé• {recomendada}")
    
    # Recomendaci√≥n adicional basada en l√≥gica
    if genero == "acci√≥n":
        print("üçø No olvides las palomitas, ¬°ser√° intenso!")
    elif genero == "comedia":
        print("üòÇ Prep√°rate para re√≠r mucho")
    else:
        print("üì∫ Disfruta tu pel√≠cula")
else:
    print(f"Lo siento, no tengo recomendaciones para '{genero}'")
    print("¬øQuiz√°s quisiste decir uno de estos?", list(peliculas.keys()))
```

### **Ejemplo 3: Verificador de contrase√±a segura**
```python
# VERIFICADOR INTELIGENTE DE CONTRASE√ëAS SEGURAS
print("üîê ANALIZADOR DE CONTRASE√ëAS SEGURAS üîê")

def analizar_contrase√±a(password):
    """Funci√≥n que simula inteligencia al analizar seguridad"""
    
    puntos = 0
    feedback = []
    
    # Reglas de seguridad (l√≥gica booleana)
    tiene_mayuscula = any(c.isupper() for c in password)
    tiene_minuscula = any(c.islower() for c in password)
    tiene_numero = any(c.isdigit() for c in password)
    tiene_especial = any(not c.isalnum() for c in password)
    longitud_ok = len(password) >= 8
    
    # An√°lisis con puntuaci√≥n
    if longitud_ok:
        puntos += 2
        feedback.append("‚úÖ Longitud adecuada (+8 caracteres)")
    else:
        feedback.append("‚ùå Muy corta (necesita 8+ caracteres)")
    
    if tiene_mayuscula and tiene_minuscula:
        puntos += 2
        feedback.append("‚úÖ Mezcla de may√∫sculas y min√∫sculas")
    else:
        feedback.append("‚ùå Usa MAY√öSCULAS y min√∫sculas")
    
    if tiene_numero:
        puntos += 1
        feedback.append("‚úÖ Contiene n√∫meros")
    else:
        feedback.append("‚ùå A√±ade n√∫meros")
    
    if tiene_especial:
        puntos += 2
        feedback.append("‚úÖ Tiene caracteres especiales")
    else:
        feedback.append("‚ùå A√±ade caracteres especiales (!@#$%)")
    
    # Clasificaci√≥n final
    if puntos >= 6:
        fuerza = "FUERTE üí™"
        color = "\033[92m"  # Verde
    elif puntos >= 3:
        fuerza = "MEDIA ‚ö†Ô∏è"
        color = "\033[93m"  # Amarillo
    else:
        fuerza = "D√âBIL üö®"
        color = "\033[91m"  # Rojo
    
    return puntos, fuerza, feedback, color

# Programa principal
while True:
    contrase√±a = input("\nIngresa una contrase√±a para analizar (o 'salir'): ")
    
    if contrase√±a.lower() == 'salir':
        print("üëã ¬°Hasta luego!")
        break
    
    print("\n" + "="*50)
    print("AN√ÅLISIS DE SEGURIDAD:")
    print("="*50)
    
    puntos, fuerza, feedback, color = analizar_contrase√±a(contrase√±a)
    
    for item in feedback:
        print(item)
    
    print("\n" + "="*50)
    print(f"PUNTUACI√ìN: {puntos}/7")
    print(f"{color}NIVEL DE SEGURIDAD: {fuerza}\033[0m")
    print("="*50)
    
    # Recomendaci√≥n inteligente
    if puntos < 4:
        print("\nüí° Sugerencia: Intenta algo como 'MiPerro123!'")
```

---

## **SEMANA 2: Estructuras de Datos para L√≥gica**

### **Ejemplo 1: Recomendador de Playlists personalizado**
```python
# SISTEMA DE PLAYLISTS INTELIGENTE
print("üéß RECOMENDADOR DE PLAYLISTS PERSONALIZADO üéß")

# Base de datos musical simulada
canciones = {
    "feliz": {
        "pop": ["Happy - Pharrell Williams", "Can't Stop the Feeling - Justin Timberlake"],
        "rock": ["Walking on Sunshine - Katrina & The Waves", "Good Vibrations - Beach Boys"]
    },
    "triste": {
        "baladas": ["Someone Like You - Adele", "Yesterday - The Beatles"],
        "indie": ["Skinny Love - Bon Iver", "The Scientist - Coldplay"]
    },
    "energ√©tico": {
        "electr√≥nica": ["Titanium - David Guetta", "Wake Me Up - Avicii"],
        "hiphop": ["Stronger - Kanye West", "Lose Yourself - Eminem"]
    }
}

# Perfil del usuario (se puede expandir)
usuario = {
    "nombre": "Alex",
    "edad": 16,
    "g√©neros_favoritos": ["pop", "rock"],
    "estado_anterior": "feliz"
}

# Sistema de recomendaci√≥n l√≥gica
def recomendar_playlist(estado_animo, preferencias):
    """Recomienda playlist basado en l√≥gica de estado de √°nimo"""
    
    print(f"\nHola {usuario['nombre']}! Detecto que est√°s {estado_animo}...")
    
    if estado_animo in canciones:
        print(f"üéµ Playlist para estar {estado_animo}:")
        
        # L√≥gica: priorizar g√©neros favoritos
        for genero in preferencias:
            if genero in canciones[estado_animo]:
                print(f"\n  {genero.upper()}:")
                for cancion in canciones[estado_animo][genero]:
                    print(f"    ‚Ä¢ {cancion}")
                
                # Si encontramos coincidencia, salimos
                break
        else:
            # Si no hay coincidencia, mostramos todo
            print("  Te recomiendo explorar:")
            for genero, lista in canciones[estado_animo].items():
                print(f"\n  {genero.upper()}:")
                for cancion in lista[:2]:  # Solo 2 por g√©nero
                    print(f"    ‚Ä¢ {cancion}")
    else:
        print("No tengo playlist para ese estado. ¬øQuiz√°s 'feliz', 'triste' o 'energ√©tico'?")

# Interacci√≥n
print("¬øC√≥mo te sientes hoy?")
print("Opciones: feliz, triste, energ√©tico")
estado = input("Tu estado: ").lower()

recomendar_playlist(estado, usuario["g√©neros_favoritos"])

# An√°lisis de patrones (simulaci√≥n simple de IA)
print("\n" + "="*50)
print("üìä TU HISTORIAL MUSICAL:")
print("="*50)

historial = [("feliz", "pop"), ("triste", "baladas"), ("feliz", "rock")]

for estado, genero in historial:
    print(f"Cuando estabas {estado}, escuchabas {genero}")

# Predicci√≥n simple
print("\nüí° Basado en tu historial, cuando est√©s feliz probablemente disfrutes rock")
```

### **Ejemplo 2: Sistema de inventario inteligente para videojuegos**
```python
# INVENTARIO INTELIGENTE DE VIDEOJUEGOS
print("üéÆ GESTOR DE COLECCI√ìN DE VIDEOJUEGOS üéÆ")

class InventarioVideojuegos:
    def __init__(self):
        self.juegos = {}
        self.estadisticas = {
            "total_juegos": 0,
            "por_genero": {},
            "por_plataforma": {}
        }
    
    def agregar_juego(self):
        """Agrega juego con validaci√≥n inteligente"""
        print("\n‚ûï AGREGAR NUEVO JUEGO")
        
        nombre = input("Nombre del juego: ")
        
        # Validaci√≥n: no duplicados
        if nombre in self.juegos:
            print(f"‚ö†Ô∏è  '{nombre}' ya est√° en tu colecci√≥n")
            return
        
        genero = input("G√©nero (aventura, shooter, rpg, deporte): ")
        plataforma = input("Plataforma (PC, PS5, Xbox, Switch): ")
        horas = int(input("Horas jugadas: "))
        completado = input("¬øCompletado? (si/no): ").lower() == "si"
        
        # Almacenamiento estructurado
        self.juegos[nombre] = {
            "g√©nero": genero,
            "plataforma": plataforma,
            "horas": horas,
            "completado": completado,
            "fecha_registro": "2024-01-15"  # Podr√≠a ser datetime.now()
        }
        
        print(f"‚úÖ '{nombre}' agregado exitosamente")
        self.actualizar_estadisticas()
    
    def actualizar_estadisticas(self):
        """Actualiza estad√≠sticas autom√°ticamente"""
        self.estadisticas["total_juegos"] = len(self.juegos)
        
        # Conteo por g√©nero
        generos = [info["g√©nero"] for info in self.juegos.values()]
        self.estadisticas["por_genero"] = {}
        for g in generos:
            self.estadisticas["por_genero"][g] = generos.count(g)
        
        # Conteo por plataforma
        plataformas = [info["plataforma"] for info in self.juegos.values()]
        self.estadisticas["por_plataforma"] = {}
        for p in plataformas:
            self.estadisticas["por_plataforma"][p] = plataformas.count(p)
    
    def recomendar_juego(self):
        """Recomienda juego basado en patrones"""
        print("\nüéØ RECOMENDACI√ìN INTELIGENTE")
        
        if not self.juegos:
            print("Agrega juegos primero para recibir recomendaciones")
            return
        
        # Encuentra g√©nero m√°s jugado
        genero_favorito = max(
            self.estadisticas["por_genero"].items(),
            key=lambda x: x[1]
        )[0]
        
        # Encuentra juegos no completados del g√©nero favorito
        juegos_no_completados = [
            nombre for nombre, info in self.juegos.items()
            if info["g√©nero"] == genero_favorito and not info["completado"]
        ]
        
        if juegos_no_completados:
            print(f"Basado en tu preferencia por {genero_favorito}:")
            print(f"Deber√≠as terminar: {juegos_no_completados[0]}")
        else:
            # Sugiere juego con menos horas
            juego_menos_horas = min(
                self.juegos.items(),
                key=lambda x: x[1]["horas"]
            )[0]
            print(f"¬øHas probado {juego_menos_horas}? Solo tiene {self.juegos[juego_menos_horas]['horas']} horas")
    
    def mostrar_estadisticas(self):
        """Muestra an√°lisis inteligente"""
        print("\n" + "="*50)
        print("üìà ESTAD√çSTICAS INTELIGENTES")
        print("="*50)
        
        print(f"Total de juegos: {self.estadisticas['total_juegos']}")
        
        print("\nDistribuci√≥n por g√©nero:")
        for genero, cantidad in self.estadisticas["por_genero"].items():
            porcentaje = (cantidad / self.estadisticas["total_juegos"]) * 100
            print(f"  {genero}: {cantidad} juegos ({porcentaje:.1f}%)")
        
        print("\nDistribuci√≥n por plataforma:")
        for plataforma, cantidad in self.estadisticas["por_plataforma"].items():
            print(f"  {plataforma}: {cantidad} juegos")
        
        # An√°lisis de horas
        total_horas = sum(info["horas"] for info in self.juegos.values())
        print(f"\n‚è±Ô∏è  Horas totales jugadas: {total_horas}")
        print(f"üìä Promedio por juego: {total_horas/len(self.juegos):.1f} horas")
        
        # Juego m√°s jugado
        if self.juegos:
            mas_jugado = max(self.juegos.items(), key=lambda x: x[1]["horas"])
            print(f"üéÆ Juego m√°s jugado: {mas_jugado[0]} ({mas_jugado[1]['horas']} horas)")

# Uso del sistema
inventario = InventarioVideojuegos()

# Agregar algunos juegos de ejemplo
inventario.juegos = {
    "The Legend of Zelda": {"g√©nero": "aventura", "plataforma": "Switch", "horas": 45, "completado": True},
    "Call of Duty": {"g√©nero": "shooter", "plataforma": "PS5", "horas": 30, "completado": False},
    "FIFA 23": {"g√©nero": "deporte", "plataforma": "Xbox", "horas": 60, "completado": False}
}

inventario.actualizar_estadisticas()
inventario.mostrar_estadisticas()
inventario.recomendar_juego()
```

### **Ejemplo 3: Sistema de estudio personalizado**
```python
# SISTEMA DE ESTUDIO PERSONALIZADO INTELIGENTE
print("üìö ASISTENTE DE ESTUDIO INTELIGENTE üìö")

class AsistenteEstudio:
    def __init__(self):
        self.materias = {}
        self.horario_estudio = {}
        self.rendimiento = {}
    
    def agregar_materia(self):
        """Agrega materia con sistema de priorizaci√≥n"""
        print("\n‚ûï NUEVA MATERIA")
        
        nombre = input("Nombre de la materia: ")
        dificultad = input("Dificultad (baja, media, alta): ")
        examen_proximo = input("¬øCu√°ndo es el pr√≥ximo examen? (dd/mm): ")
        horas_semanales = int(input("Horas de estudio semanales recomendadas: "))
        
        self.materias[nombre] = {
            "dificultad": dificultad,
            "examen": examen_proximo,
            "horas": horas_semanales,
            "sesiones_completadas": 0,
            "nota_objetivo": 0
        }
        
        print(f"‚úÖ {nombre} agregada al sistema")
        
        # Sugerencia autom√°tica basada en dificultad
        if dificultad == "alta":
            print(f"üí° Sugerencia: Divide el estudio de {nombre} en sesiones cortas diarias")
    
    def generar_horario(self):
        """Genera horario inteligente basado en materias"""
        print("\n‚è∞ GENERANDO HORARIO INTELIGENTE")
        
        if not self.materias:
            print("Primero agrega materias")
            return
        
        # Priorizar por proximidad de examen y dificultad
        prioridad = {}
        for nombre, info in self.materias.items():
            puntaje = 0
            
            # L√≥gica de priorizaci√≥n
            if info["dificultad"] == "alta":
                puntaje += 3
            elif info["dificultad"] == "media":
                puntaje += 2
            else:
                puntaje += 1
            
            # A√±adir m√°s l√≥gica seg√∫n fecha de examen
            puntaje += 5  # Temporal, se podr√≠a calcular d√≠as restantes
            
            prioridad[nombre] = puntaje
        
        # Ordenar por prioridad
        materias_ordenadas = sorted(prioridad.items(), key=lambda x: x[1], reverse=True)
        
        print("\nüìÖ HORARIO RECOMENDADO:")
        dias = ["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes"]
        
        for i, (materia, _) in enumerate(materias_ordenadas[:5]):
            print(f"{dias[i]}: {materia} - {self.materias[materia]['horas']} horas")
            
            # Sugerencia espec√≠fica
            if self.materias[materia]["dificultad"] == "alta":
                print(f"   üí° Enf√≥cate en ejercicios pr√°cticos")
            elif self.materias[materia]["dificultad"] == "media":
                print(f"   üí° Combina teor√≠a y pr√°ctica")
            else:
                print(f"   üí° Repasa conceptos clave")
    
    def registrar_sesion(self):
        """Registra sesi√≥n de estudio con an√°lisis"""
        print("\nüìù REGISTRAR SESI√ìN DE ESTUDIO")
        
        materia = input("Materia estudiada: ")
        
        if materia not in self.materias:
            print("Materia no encontrada")
            return
        
        duracion = int(input("Duraci√≥n en minutos: "))
        tema = input("Tema estudiado: ")
        comprension = input("Nivel de comprensi√≥n (1-5): ")
        
        # Actualizar estad√≠sticas
        self.materias[materia]["sesiones_completadas"] += 1
        
        # An√°lisis de productividad
        horas_totales = (duracion / 60) + self.materias[materia].get("horas_totales", 0)
        self.materias[materia]["horas_totales"] = horas_totales
        
        print(f"‚úÖ Sesi√≥n registrada")
        print(f"üìä Total sesiones de {materia}: {self.materias[materia]['sesiones_completadas']}")
        print(f"‚è±Ô∏è  Horas totales: {horas_totales:.1f}")
        
        # Feedback inteligente
        if int(comprension) <= 2:
            print("üî¥ Necesitas repasar este tema. Intenta con diferentes recursos")
        elif int(comprension) <= 4:
            print("üü° Buen progreso. Considera hacer ejercicios de pr√°ctica")
        else:
            print("üü¢ ¬°Excelente! Ya dominas este tema")
    
    def analizar_progreso(self):
        """Analiza progreso con inteligencia"""
        print("\n" + "="*50)
        print("üìä AN√ÅLISIS DE PROGRESO INTELIGENTE")
        print("="*50)
        
        if not self.materias:
            print("No hay datos para analizar")
            return
        
        total_sesiones = sum(m["sesiones_completadas"] for m in self.materias.values())
        total_horas = sum(m.get("horas_totales", 0) for m in self.materias.values())
        
        print(f"Sesiones totales: {total_sesiones}")
        print(f"Horas totales de estudio: {total_horas:.1f}")
        
        # Materia m√°s estudiada
        if total_sesiones > 0:
            materia_mas_estudiada = max(
                self.materias.items(),
                key=lambda x: x[1].get("sesiones_completadas", 0)
            )
            print(f"\nüìñ Materia m√°s estudiada: {materia_mas_estudiada[0]}")
            print(f"   Sesiones: {materia_mas_estudiada[1]['sesiones_completadas']}")
        
        # Recomendaci√≥n general
        print("\nüí° RECOMENDACIONES:")
        for materia, info in self.materias.items():
            sesiones = info.get("sesiones_completadas", 0)
            if sesiones == 0:
                print(f"  ‚Ä¢ Deber√≠as empezar a estudiar {materia}")
            elif sesiones < 3:
                print(f"  ‚Ä¢ {materia}: Aumenta la frecuencia de estudio")
            else:
                print(f"  ‚Ä¢ {materia}: Buen ritmo, mant√©n la consistencia")

# Uso del sistema
asistente = AsistenteEstudio()

# Ejemplo de uso
asistente.materias = {
    "Matem√°ticas": {"dificultad": "alta", "examen": "15/03", "horas": 6, "sesiones_completadas": 3, "horas_totales": 4.5},
    "Historia": {"dificultad": "media", "examen": "20/03", "horas": 4, "sesiones_completadas": 2, "horas_totales": 3.0},
    "Biolog√≠a": {"dificultad": "baja", "examen": "25/03", "horas": 3, "sesiones_completadas": 1, "horas_totales": 1.5}
}

asistente.generar_horario()
asistente.analizar_progreso()
```

---

## **SEMANA 3: Funciones y M√≥dulos L√≥gicos**

### **Ejemplo 1: Asistente de Tareas Inteligente**
```python
# ASISTENTE DE TAREAS CON INTELIGENCIA B√ÅSICA
print("‚úÖ ASISTENTE DE TAREAS INTELIGENTE ‚úÖ")

import datetime

class AsistenteTareas:
    def __init__(self):
        self.tareas = []
        self.categorias = ["Escuela", "Casa", "Personal", "Trabajo"]
    
    def agregar_tarea(self):
        """Agrega tarea con validaci√≥n inteligente"""
        print("\n‚ûï NUEVA TAREA")
        
        titulo = input("T√≠tulo de la tarea: ")
        
        # Verificar si ya existe tarea similar
        tareas_similares = [t for t in self.tareas if titulo.lower() in t["titulo"].lower()]
        if tareas_similares:
            print(f"‚ö†Ô∏è  Ya tienes tareas similares:")
            for t in tareas_similares[:2]:
                print(f"   ‚Ä¢ {t['titulo']} (Estado: {t['estado']})")
        
        descripcion = input("Descripci√≥n: ")
        
        # Categor√≠a con sugerencia autom√°tica
        print("\nCategor√≠as disponibles:", ", ".join(self.categorias))
        categoria = input("Categor√≠a: ")
        
        if categoria not in self.categorias:
            print(f"‚ö†Ô∏è  Categor√≠a nueva. A√±adiendo '{categoria}' al sistema")
            self.categorias.append(categoria)
        
        # Fecha con l√≥gica inteligente
        hoy = datetime.datetime.now()
        
        fecha_str = input("Fecha l√≠mite (dd/mm/aaaa o 'hoy', 'ma√±ana'): ")
        
        if fecha_str.lower() == "hoy":
            fecha = hoy
        elif fecha_str.lower() == "ma√±ana":
            fecha = hoy + datetime.timedelta(days=1)
        else:
            try:
                fecha = datetime.datetime.strptime(fecha_str, "%d/%m/%Y")
            except:
                print("Formato incorrecto. Usando fecha de hoy")
                fecha = hoy
        
        # Prioridad autom√°tica basada en fecha
        dias_restantes = (fecha - hoy).days
        
        if dias_restantes < 0:
            prioridad = "URGENTE üî¥"
        elif dias_restantes <= 1:
            prioridad = "ALTA üü†"
        elif dias_restantes <= 3:
            prioridad = "MEDIA üü°"
        else:
            prioridad = "BAJA üü¢"
        
        # Crear tarea
        tarea = {
            "id": len(self.tareas) + 1,
            "titulo": titulo,
            "descripcion": descripcion,
            "categoria": categoria,
            "fecha": fecha,
            "prioridad": prioridad,
            "estado": "Pendiente",
            "fecha_creacion": hoy
        }
        
        self.tareas.append(tarea)
        print(f"‚úÖ Tarea '{titulo}' agregada con prioridad {prioridad}")
        
        # Sugerencia inteligente
        if dias_restantes < 2:
            print(f"‚è∞ ¬°Esta tarea es urgente! Considera hacerla ahora mismo")
    
    def sugerir_tarea_diaria(self):
        """Sugiere tarea basada en hora del d√≠a y prioridad"""
        print("\nü§ñ SUGERENCIA INTELIGENTE DEL D√çA")
        
        if not self.tareas:
            print("No hay tareas. ¬°Agrega algunas!")
            return
        
        hora_actual = datetime.datetime.now().hour
        
        # L√≥gica basada en hora del d√≠a
        if 6 <= hora_actual < 12:
            momento = "ma√±ana"
            tipo_tarea = "complejas"  # Ma√±ana: mayor concentraci√≥n
        elif 12 <= hora_actual < 18:
            momento = "tarde"
            tipo_tarea = "moderadas"  # Tarde: energ√≠a media
        else:
            momento = "noche"
            tipo_tarea = "sencillas"  # Noche: menor energ√≠a
        
        print(f"Son las {hora_actual}:00 ({momento})")
        print(f"üí° Te sugiero trabajar en tareas {tipo_tarea}")
        
        # Filtrar tareas pendientes
        pendientes = [t for t in self.tareas if t["estado"] == "Pendiente"]
        
        if pendientes:
            # Ordenar por prioridad y fecha
            pendientes_ordenadas = sorted(
                pendientes,
                key=lambda x: (x["prioridad"], x["fecha"])
            )
            
            tarea_sugerida = pendientes_ordenadas[0]
            print(f"\nüéØ TAREA SUGERIDA:")
            print(f"   ‚Ä¢ {tarea_sugerida['titulo']}")
            print(f"   ‚Ä¢ Prioridad: {tarea_sugerida['prioridad']}")
            print(f"   ‚Ä¢ Categor√≠a: {tarea_sugerida['categoria']}")
            
            # Motivaci√≥n basada en hora
            if momento == "ma√±ana":
                print("   üåÖ ¬°Buen d√≠a para ser productivo!")
            elif momento == "tarde":
                print("   ‚òÄÔ∏è  ¬°Vamos que se puede!")
            else:
                print("   üåô ¬°√öltimo esfuerzo del d√≠a!")
        else:
            print("üéâ ¬°No hay tareas pendientes! Buen trabajo")
    
    def completar_tarea(self):
        """Marca tarea como completada con retroalimentaci√≥n"""
        print("\nüèÅ COMPLETAR TAREA")
        
        self.mostrar_tareas_pendientes()
        
        if not any(t["estado"] == "Pendiente" for t in self.tareas):
            print("No hay tareas pendientes")
            return
        
        try:
            id_tarea = int(input("ID de la tarea a completar: "))
            
            for tarea in self.tareas:
                if tarea["id"] == id_tarea and tarea["estado"] == "Pendiente":
                    tarea["estado"] = "Completada"
                    tarea["fecha_completada"] = datetime.datetime.now()
                    
                    # Calcular tiempo tomado
                    tiempo = tarea["fecha_completada"] - tarea["fecha_creacion"]
                    horas = tiempo.total_seconds() / 3600
                    
                    print(f"üéâ ¬°Tarea '{tarea['titulo']}' completada!")
                    print(f"‚è±Ô∏è  Tom√≥ {horas:.1f} horas desde su creaci√≥n")
                    
                    # Retroalimentaci√≥n motivacional
                    if horas < 1:
                        print("‚ö° ¬°Qu√© velocidad! Eres muy eficiente")
                    elif horas < 24:
                        print("‚úÖ Bien hecho, completada a tiempo")
                    else:
                        print("üí™ Perseverancia premiada, ¬°sigamos adelante!")
                    
                    break
            else:
                print("ID no encontrado o tarea ya completada")
        except ValueError:
            print("Por favor ingresa un n√∫mero v√°lido")
    
    def mostrar_estadisticas(self):
        """Muestra an√°lisis inteligente de productividad"""
        print("\n" + "="*50)
        print("üìä ESTAD√çSTICAS INTELIGENTES")
        print("="*50)
        
        total = len(self.tareas)
        completadas = sum(1 for t in self.tareas if t["estado"] == "Completada")
        pendientes = total - completadas
        
        print(f"Tareas totales: {total}")
        print(f"‚úÖ Completadas: {completadas}")
        print(f"‚è≥ Pendientes: {pendientes}")
        
        if total > 0:
            porcentaje = (completadas / total) * 100
            print(f"üìà Progreso: {porcentaje:.1f}%")
            
            # An√°lisis por categor√≠a
            print("\nüìÅ POR CATEGOR√çA:")
            for categoria in self.categorias:
                cat_tareas = [t for t in self.tareas if t["categoria"] == categoria]
                if cat_tareas:
                    cat_completadas = sum(1 for t in cat_tareas if t["estado"] == "Completada")
                    print(f"  {categoria}: {cat_completadas}/{len(cat_tareas)} completadas")
            
            # Tendencias
            print("\nüìÖ TENDENCIA:")
            if pendientes == 0:
                print("üéä ¬°Todas las tareas completadas! Excelente trabajo")
            elif porcentaje > 80:
                print("üî• ¬°Vas muy bien! Sigue as√≠")
            elif porcentaje > 50:
                print("üëç Buen progreso, mant√©n el ritmo")
            else:
                print("üí™ √Ånimo, cada tarea completada es un paso adelante")
    
    def mostrar_tareas_pendientes(self):
        """Muestra tareas pendientes ordenadas inteligentemente"""
        pendientes = [t for t in self.tareas if t["estado"] == "Pendiente"]
        
        if not pendientes:
            print("\nüéâ ¬°No hay tareas pendientes!")
            return
        
        print("\nüìã TAREAS PENDIENTES:")
        print("-" * 50)
        
        # Ordenar por prioridad y fecha
        pendientes_ordenadas = sorted(
            pendientes,
            key=lambda x: (x["prioridad"], x["fecha"])
        )
        
        for tarea in pendientes_ordenadas:
            dias = (tarea["fecha"] - datetime.datetime.now()).days
            print(f"\nID: {tarea['id']}")
            print(f"üìå {tarea['titulo']}")
            print(f"   üìç {tarea['categoria']}")
            print(f"   ‚è∞ {tarea['prioridad']} - Vence en {dias} d√≠as")
            print(f"   üìù {tarea['descripcion'][:50]}...")

# Programa principal
def main():
    asistente = AsistenteTareas()
    
    # Datos de ejemplo para demostraci√≥n
    hoy = datetime.datetime.now()
    
    asistente.tareas = [
        {
            "id": 1,
            "titulo": "Estudiar para examen de matem√°ticas",
            "descripcion": "Repasar cap√≠tulos 3 y 4",
            "categoria": "Escuela",
            "fecha": hoy + datetime.timedelta(days=1),
            "prioridad": "ALTA üü†",
            "estado": "Pendiente",
            "fecha_creacion": hoy - datetime.timedelta(days=2)
        },
        {
            "id": 2,
            "titulo": "Limpiar la habitaci√≥n",
            "descripcion": "Organizar escritorio y guardar ropa",
            "categoria": "Casa",
            "fecha": hoy + datetime.timedelta(days=3),
            "prioridad": "MEDIA üü°",
            "estado": "Completada",
            "fecha_creacion": hoy - datetime.timedelta(days=5),
            "fecha_completada": hoy - datetime.timedelta(days=1)
        },
        {
            "id": 3,
            "titulo": "Hacer ejercicio",
            "descripcion": "30 minutos de cardio",
            "categoria": "Personal",
            "fecha": hoy,
            "prioridad": "URGENTE üî¥",
            "est
